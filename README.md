# Kcloud

The prototype considers a private Ethereum blockchain network. Ethereum is the first blockchain to support Turing-complete smart contracts, and the most widely used for the implementation of distributed applications, accounting for 198B US\$  in market capitalization.  
Ethereum-based permissioned blockchains were investigated to be used in enterprise software by large investment banks in the derivatives and payments markets and clearing and settlement mechanisms, as well as by countless other parties to build enterprise software solutions. 

![image](https://github.com/ollie041114/kcloud/assets/58882951/2a874d92-6976-40ad-b884-9c6e351dd7c3)

Each node of the blockchain network runs on a mini-PC connected to other nodes over a private VPN network.
A node's mini-PC is configured as follows:
1. Operating system: Ubuntu 18
2. Intel(R) Celeron(R) J4105 @ 1.50GHz 4 cores, 4 threads
3. 8 gb of internal memory and 2 gb of ram

We chose Go-Ethereum - geth as the Ethereum client for the nodes.
Go-Ethereum is one of the first three clients developed for Ethereum, along with the Python and C implementations. Using geth  allowed us to access Ethereum’s developer infrastructure and benefit from its ecosystem of open-source code, strong community, and extensive documentation.

### Front-end
The front-end of each node is implemented using the Javascript library React. Specifically, the \emph{web3.js} library is used to create Ethereum transaction objects. The nodes store private keys as local files, which are read by the library web3.js to sign the transactions and send them to the Ethereum network.

To handle the events generated by the smart contract executions, which determine the information updates on the front-end applications, we use theGraph, a blockchain indexing protocol that organizes blockchain events into a GraphQL-compatible queriable database. In this protocol, a Graph Node is an open-source Rust implementation that queries the Ethereum blockchain at a given port for events, and deterministically updates a data store, which can be queried via theGraphQL endpoint. A Graph node is running inside of a docker container, scans the geth client for new blocks, and stores the events logged in the blocks into a GraphQL database, according to a predefined logic. It is then possible to designate an event handler for each of the events. An event handler defines how to relate event parameters, like the sensor id and the sensor reading values, to the database values. For example, this example core handles sensorDataEvent by linking it to the drum:

```
export function handleSensorData(event: SensorDataEvent): void {
	let sensorDatum = new SensorDatum(event.params.data_id.toString());
	// create a new "sensor reading"
	let drum = Drum.load(event.params.drum_id.toString());
	// load a drum currently associated with the sensor reading:
	if (drum) {
		// link this sensor reading to this drum
		sensorData.drum = drum.id;
		let currentStatus = drum.currentStatus;
		drum.save();
	}
	// update the values of the sensor data
	sensorData.time = event.params.time;
	sensorData.GPS_longitude = event.params.longitude;
	sensorData.GPS_latitude = event.params.latitude;
	sensorData.accX = event.params.accX;
	sensorData.save();
}
\end{lstlisting}
```

This way, we can achieve complex queries against the entire sensor data history, while keeping the complexity of the smart contract low, e.g.:

```
drums(where: {sensorId: 2}) {
	temperature(where: {value: {gte: 100}) {
		alarmReading
	}
}
```

### Network
To prepare the prototype network for the demonstration, we have followed this procedure: 

1. Turn on the VPN
    
Each mini PC is first connected to a VPN network, prepared in advance, via a generic Linux network connection GUI, using its uniquely assigned password provided by the host. Then, each mini-PC will have unique host address and the same subnet address under the same network, to which we can group them together by the add peer command:
    
```
admin.addPeer("enode://c70c8a9510aa002f075de8d14d67df2bb9190d0106cf2e68bc7ef4
1ddc0a34b4cbf8988435fb677bd4b12b338434c92897130f34cdce08b8dfa68085dbb11c8b@19
2.168.0.10:30303?discport=0")
```
in which the information after the “@” symbol above will be different based on the VPN network the node is connected to.

To become a blockchain node, each mini PC needs to install and run Geth software with custom instructions:   

**Connect to geth**: 
    
  

First, the main node (the one bootstrapping the network) needs to specify genesis file for Geth, identifying the parameters of the underlying blockchain system (i.e. chain id, gas limit, mining difficulty, etc …). In our case, there was no need to specify fees for gas, so they were set to 0. Example of genesis file:

```
   {
   "config": {
     "chainId": 1500,
     "homesteadBlock": 0,
     "eip150Block": 0,
     "eip150Hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
     "eip155Block": 0,
     "eip158Block": 0,
     "byzantiumBlock": 0,
     "constantinopleBlock": 0,
     "petersburgBlock": 0,
     "istanbulBlock": 0,
     "ethash": {}
   },
   "nonce": "0x0",
   "timestamp": "0x612b767c",
   "extraData": "0x0000000000000000000000000000000000000000000000000000000000000000",
   "gasLimit": "0x47b760",
   "difficulty": "0x80000",
   "mixHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
   "coinbase": "0x0000000000000000000000000000000000000000",
   "alloc": {},

   "number": "0x0",
   "gasUsed": "0x0",
   "parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
   "baseFeePerGas": null
 }
```
    
After this, geth can be started with the following commands, first by the “main” node, and later by the other computers connecting to the network, where --port and --http.port are supposed to be different across each node:
    
```
     geth --networkid 1500 --datadir ${folderWithGenesisFile} \
 --graphql --port 30306 \
 --http --http.port "8548" --http.addr "0.0.0.0" \
 --http.corsdomain "*" --http.api "eth, net, web3, miner, debug, personal, rpc" \
 --allow-insecure-unlock --rpc.allow-unprotected-txs console 
```
    
after that we can see Node information like this: 
    
```
     {
   enode: "enode://c70c8a9510aa002f075de8d14d67df2bb9190d0106cf2e68bc7ef41ddc0a34b
   4cbf8988435fb677bd4b12b338434c92897130f34cdce08b8dfa68085dbb11c8b@192.168.178.4
   2:30303?discport=0",
   enr: "enr:-Jy4QAiDv7DT_zjtQlahvz4pAnbEkSrRcUUaespUH4-TgsKhM9UFKo6LTq5Gkj-9GcN22
   1X08VS2YpMtSDP05MLxi5CGAX7nurugg2V0aMfGhF31F0-AgmlkgnY0gmlwhMCosiqJc2VjcDI1Nmsx
   oQPHDIqVEKoALwdd6NFNZ98ruRkNAQbPLmi8fvQd3Ao0tIRzbmFwwIN0Y3CCdl8",
   id: "3c52f5df1cc5c99feed783b2e10ce78d2fa217104eb457d7c0ef3c474ae7e48a",
   ip: "192.168.178.42",
   listenAddr: "[::]:30303",
   name: "Geth/v1.10.13-stable-7a0c19f8/linux-amd64/go1.17.2",
   ports: {
     discovery: 0,
     listener: 30303
   },
   protocols: {
     eth: {
       config: {
         byzantiumBlock: 0,
         chainId: 1500,
         constantinopleBlock: 0,
         eip150Block: 0,
         eip150Hash: "0x0000000000000000000000000000000000000000000000000000000000000000",
         eip155Block: 0,
         eip158Block: 0,
         ethash: {},
         homesteadBlock: 0,
         istanbulBlock: 0,
         petersburgBlock: 0
       },
       difficulty: 84307729,
       genesis: "0x42c87465a831bbbca41b25362c23569f43126b80e401455267477914160c6f49",
       head: "0x04bfde0a7a33c2dc3e257bb7cb61ede88275a3e1627d9b6031fd9d11a780e9fd",
       network: 1500
     },
     snap: {}
   }
 }
```
    
in which the take away information here is the enode: \emph{enode://...1c8b@192.168.178.42:30303?discport=0}

The information after symbol @ will be changed depending on which network the mini-PC is connected to, this is important for the VPN connection that will be discussed further below.
    
Then in each node, we need to unlock a Geth account to mine transactions, in order to stay up to date with other nodes later, when they are in the same network:


### Smart contract.

With all such setup, we deploy the prepared smart contract from the master node using truffle package and a simple javascript deployment scripts to Geth network.

Finally, we use a pre-made structured graphing server called TheGraph to read events from the deployed smart contract

In detail, three components are launched in docker containers:


1. GraphQL querying endpoint reading from postgreSQL database ran inside mini PC.
2. postreSQL stores data emitted by GraphNode.
3. GraphNode subscribe to blockchain Events on localhost port 8545.


A single Solidity smart contract is deployed in the Ethereum private network. This smart contract exposes all the functions associated with the steps of the scenario depicted in Fig.~\ref{fig:scenario}, e.g., to register a new drum in the system or to accept new sensor readings from a drum. In some cases, the execution of a step may require to pass large files to the smart contract, like a scan of paper documents or a photo of a drum. In these cases, the files are uploaded to a distributed file system instance and their hash is stored  in the smart contract, thus effectively distributing the file content across the network participants. When needed, the smart contract can always retrieve a file from the distributed file system. The use of hashes ensures that the correct version of the data is obtained. However, it does not guarantee the availability of the images. We use IPFS~\citep{IPFSDOC} as a distributed file system in the prototype. For simplicity, we considered the public instance of the IPFS file system in the prototype demonstration. However, the prototype could be interfaced with a private instance of IPFS that could be joined only by the nodes involved in the scenario.

More in detail, we define the following types of participants in the system: 

1. **Observers**: With regards to a drum, each participating node is an observer by default. Observers cannot perform any state-changing actions, they can only monitor the drums. 
2. **Originator**: This is the participant that first registers a drum in the system. An originator maintains writing rights for a drum during the initial phases before transit, after which the drum ownership is transferred to a different owner, e.g., a temporary storage facility.
3. **Owner**: For a given drum, this is the participant in charge of the facility where the drum currently resides. Owners can perform the administrative procedures only after the drum is transferred to their facility (confirmed by the previous owner during the preparation for transit).
4. **Operator**: An operator node is allowed to observe the alarms generated by the system and dismiss them as necessary. This role is granted by default to originators/current owner facilities, but can also be granted to remote nodes specifically reserved for such task.


![image](https://github.com/ollie041114/kcloud/assets/58882951/0dcf3117-829a-44a9-9f50-73f946a6f3e1)



The smart contract exposes the following methods, which can be invoked by the participants (if allowed) by issuing a transaction (see also Fig.~\ref{fig:schema} for the data schema used by the implemented smart contract):

### Transaction Description for the Drum Tracking System

#### System setup transaction:
- `registerParticipant`: registers the public account associated with a participant and designates its global role (i.e. whether it is a data acquisition node capable of sending sensor readings), specifying its location, name, address, etc.
    
#### General administrative transactions (can be called only by the current owner of a drum):
- `enrollment`: a drum object is created and paired with an existing sensor. The node invoking this transaction becomes a drum originator and current owner. 
- `packaging`: indicates that a drum is loaded and sealed, and physically paired with a sensor. 
- `transit 1`: preparing the drum for transit to another facility. Ownership is transferred to the node in charge of the destination facility. 
- `temporary storage`: confirmation that the destination facility node received the drum and is preparing it for the temporary storage.
- `transit 2`: preparing the drum for transit to the long-term storage. Ownership is transferred to the node in charge of the destination facility. 
- `taking over`: ownership is transferred to the long-term storage facility.

#### Transactions invoked only by the sensors and data acquisition nodes:
- `changeSensorDrum`: called at the enrollment stage by a sensor to register the drum to which it is attached. 
- `sendSensorReading`: can be called only by a data acquisition node. It sends a sensor reading of a drum to the system. 

<!-- - `newAlarm`: special events emitted when sensor data associated with the particular sensor falls out of the specified range. TRANSACTION OR EVENT??? -->


### Sensor modules

### Technical Prototype of the IoT-Blockchain Waste Management System

To demonstrate the capabilities of the IoT-Blockchain Waste Management System, a technical prototype was created consisting of five drums that simulate waste. Mechanical parts were developed to attach the IoT sensor modules to each drum (see Fig.~\ref{fig:drums}).

The IoT sensor module includes a 5000mA battery, a main board sensor PCB, a radiation sensor, an acceleration sensor, a GPS module, a temperature and humidity sensor, a low-power MCU, and an LTE Cat.M1 communication module. The technical details of the IoT sensor module's implementation are available in the Appendix. For network communication, two environments were considered: a LoRaWAN-based network and an LTE-based network.

The sensors were connected to an Ethereum network node designated for data acquisition. The node runs a Python process via the \emph{Pyserial} module to process the data received from the sensors and convert it to an Ethereum-compatible format. The data is then sent to the Ethereum network as a transaction object created using the \emph{web3.py} library. The transactions are signed with a unique counter for each transaction to ensure they can be sent in real time and confirmed.

A dynamic view of the interaction among components in the system is shown below. The Sensor layer represents the IoT sensors sending data, which are collected by the Python layer of the data aggregation node. The blockchain data layer is the Ethereum private node client implemented by all nodes in the network. An Application layer represents a front-end application built on the blockchain layer and can use the IPFS to store large data. 

![image](https://github.com/ollie041114/kcloud/assets/58882951/70cded78-f19c-4f72-96ac-37d9534609c6)

During the use case demonstration, a commercial general-purpose LTE network was used instead of a private communication network to cover the demonstration area. The proposed system can be extended to include multiple nodes. 

Finally, this brings together all the elements of the prototype to show their interaction during the operation of the system. The Sensor layer represents the sensors sending data, which are collected by the Python layer of a data aggregation node. The blockchain data layer is the Ethereum private node client implemented by all the nodes of the network. The Application layer represents a front-end application built on top of the blockchain-layer, which, if necessary, can also use the IPFS to store large data.


